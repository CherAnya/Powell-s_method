#include <iostream> 
#include <math.h>
#include <conio.h>

using namespace std;

double f(double  x1, double x2) {
	return 4 * (x1 - 5) * (x1 - 5) + (x2 - 6) * (x2 - 6);
}

int main() {
	double  E = 0.1, min; //точность, локальный минимум
	double Z[200], h; //значение функции, шаг
	int i, j, k = 0; 
	int s = 0, I[100]; //счетчик для координат

	double p[2][2] = { {0,1}, {1,0} };  //направления 
	double X[20][20], Y[20][20], Xz[1][2]; //массивы для координат Х, У, Хmax, Ymax
	I[s] = 0; //счетчик для координат

	cout << "X0:" << endl;           
	for (i = 0; i < 1; i++)
		for (int j = 0; j < 2; j++)
			cin >> X[i][j];  
	cout << "X(" << X[0][0] << ";" << X[0][1] << ")\n"; //ввод пользователем начальной точки

	for (i = 0; i < 1; i++)             
		for (j = 0; j < 2; j++)
			Y[i][j] = X[i][j];      //Y0 = X0

	int iter = 0;

 ONE:  cout << "Iteration " << iter << endl;
	min = f(Y[I[s]][0], Y[I[s]][1]); //локальный минимум после выполненного шага в найденной точке

	i = 0;
	for (h = -50; h < 50; h++, i++)    
	{
		Z[i] = f(Y[I[s]][0] + h * p[I[s]][0], Y[I[s]][1] + h * p[I[s]][1]);
	} //перебор h и выявление значений функции

	for (i = 0; i < 100; i++)   
		if (Z[i] < min)
			min = Z[i]; //задание нового минимума, найденного предыдущим действием

	for (int index = 0; index < 100; index++)  
	{
		if (min == Z[index])
			h = index - 50;
	} //вычисление шага

	cout << "h = " << h << endl;

	Y[I[s] + 1][0] = Y[I[s]][0] + h * p[I[s]][0]; //вычисление координаты X новой точки
	Y[I[s] + 1][1] = Y[I[s]][1] + h * p[I[s]][1]; //вычисление координаты Y новой точки
	cout << "X[" << I[s] + 1 << "] = (" << Y[I[s] + 1][0] << ";" << Y[I[s] + 1][1] << ")" << endl;  //основной алгоритм                          

  TWO: if (h != 0)
  {
	I[s] = I[s] + 1;
	goto ONE;
  }

  if (h == 0)
  {
	goto THREE;
  }   
	         
THREE:  cout << "Choosing a new direction" << endl;
	X[k + 1][0] = Y[I[s] + 1][0];
	X[k + 1][1] = Y[I[s] + 1][1];
	cout << "X[" << (k + 1) << "] = (" << X[k + 1][0] << ";" << X[k + 1][1] << ")" << endl; //вывод последней точки за предыдущую итерацию

	if (pow((pow((X[k + 1][0] - X[k][0]), 2) + pow((X[k + 1][1] - X[k][1]), 2)), 1 / 2.0) < E) {
		cout << "X(k+1) - X(k) = " << pow((pow((X[k + 1][0] - X[k + 1][0]), 2) + pow((X[k + 1][1] - X[k + 1][1]), 2)), 1 / 2.0); //проверка условия останова
		Xz[0][0] = X[k + 1][0];
		Xz[0][1] = X[k + 1][1];
	}
	
	if (pow((pow((X[k + 1][0] - X[k][0]), 2) + pow((X[k + 1][1] - X[k][1]), 2)), 1 / 2.0) > E) {
		p[0][0] = Y[I[s] + 1][0] - Y[1][0];
		p[0][1] = Y[I[s] + 1][1] - Y[1][1];
		cout << "d0 = (" << p[0][0] << ";" << p[0][1] << ")" << endl; //выбор нового направления

		p[I[s]][0] = p[0][0];
		p[I[s]][1] = p[0][1];
		Y[0][0] = X[k + 1][0]; 
		Y[0][1] = X[k + 1][1];  
		k = k + 1;
		I[s] = 0;
		iter++;
		goto ONE; //задание новых координат, обнуление счетчика, переход к шагу один
	}

	cout << "\nZ(" << Xz[0][0] << ";" << Xz[0][1] << ")" << endl;
	_getch();
}